"""
placeholder_filler.py

Robust placeholder filler for insight templates.

Capabilities:
- Replace placeholders in formats: {{PLACEHOLDER}}, {PLACEHOLDER}, and mixed case
- Case-insensitive mapping to computed_values keys (computed values are normalized to UPPERCASE)
- Format floats, ints, lists, dicts, pandas DataFrames
- Insert Markdown tables for lists/dicts/tables
- Provide informative tokens for missing values: [MISSING:KEY]
- Optional strict mode: raise on missing placeholders (useful for tests)
"""

import re
import json
from typing import Dict, Any, Optional, List
import pandas as pd
import numpy as np


def _to_markdown_table_from_list_of_dicts(rows: List[Dict[str, Any]]) -> str:
    if not rows:
        return "*No rows*"
    columns = list({k for r in rows for k in r.keys()})
    header = "| " + " | ".join(columns) + " |\n"
    sep = "| " + " | ".join(["---"] * len(columns)) + " |\n"
    lines = [header, sep]
    for r in rows:
        values = [str(r.get(c, "")) for c in columns]
        lines.append("| " + " | ".join(values) + " |\n")
    return "".join(lines)


def _to_markdown_table_from_dict(d: Dict[str, Any]) -> str:
    if not d:
        return "*No data*"
    lines = ["| Key | Value |\n", "| --- | ----- |\n"]
    for k, v in d.items():
        lines.append(f"| {k} | {v} |\n")
    return "".join(lines)


class PlaceholderFiller:
    def __init__(self, template: str, analysis_results: Dict[str, Any], strict: bool = False):
        """
        Args:
            template: template string possibly generated by LLM
            analysis_results: analysis output (should contain 'computed_values')
            strict: if True, raise error on missing placeholders
        """
        self.template = template or ""
        self.analysis_results = analysis_results or {}
        self.strict = strict
        # Accept both top-level computed_values or the whole analysis_results dict
        self.computed_values = self.analysis_results.get("computed_values", {}) if isinstance(self.analysis_results, dict) else {}
        # Ensure normalization to uppercase keys for matching
        self.normalized: Dict[str, Any] = {str(k).upper(): v for k, v in self.computed_values.items()}

        # If analysis_results itself may be a flat mapping, include its uppercase keys too
        for k, v in (self.analysis_results.items() if isinstance(self.analysis_results, dict) else []):
            if k != "computed_values":
                self.normalized.setdefault(str(k).upper(), v)

    def fill(self) -> str:
        text = self.template

        # 1) Generic dynamic replacement: handle {{PLACEHOLDER}} and {PLACEHOLDER}
        text = self._fill_dynamic_placeholders(text)

        # 2) Post-process possible JSON/table placeholders
        text = self._render_complex_placeholders(text)

        # 3) Cleanup any remaining placeholders into readable tokens
        text = self._cleanup_unfilled(text)

        # 4) If strict, validate no missing markers remain
        if self.strict:
            remaining = re.findall(r"\{\{\s*([A-Za-z0-9_]+)\s*\}\}|\{\s*([A-Za-z0-9_]+)\s*\}", text)
            if remaining:
                raise ValueError(f"Missing placeholders after fill: {remaining}")

        return text

    def _fill_dynamic_placeholders(self, text: str) -> str:
        """
        Replace placeholders with values found in normalized computed_values.
        Supports numeric formatting and lists/dicts insertion.
        """
        if not self.normalized:
            return text

        pattern = re.compile(r"\{\{\s*([A-Za-z0-9_]+)\s*\}\}|\{\s*([A-Za-z0-9_]+)\s*\}")

        def repl(match):
            key = (match.group(1) or match.group(2) or "").upper()
            if not key:
                return match.group(0)

            value = self.normalized.get(key)
            if value is None:
                # no key found
                if self.strict:
                    raise KeyError(f"Missing placeholder value for {key}")
                return f"[MISSING:{key}]"

            # Format primitives
            if isinstance(value, float):
                return f"{value:.4f}"
            if isinstance(value, (int, np.integer)):
                return str(int(value))
            if isinstance(value, (str,)):
                return value
            if isinstance(value, list):
                # If list of dicts -> markdown table
                if value and isinstance(value[0], dict):
                    return _to_markdown_table_from_list_of_dicts(value)
                else:
                    return ", ".join(str(v) for v in value)
            if isinstance(value, dict):
                # convert small dicts to markdown table, otherwise JSON
                if all(isinstance(v, (str, int, float, bool, type(None))) for v in value.values()) and len(value) <= 20:
                    return _to_markdown_table_from_dict(value)
                return json.dumps(value, default=str, indent=2)
            if isinstance(value, pd.DataFrame):
                # convert to markdown table head
                rows = value.head(10).to_dict("records")
                return _to_markdown_table_from_list_of_dicts(rows)
            # fallback to JSON string
            try:
                return json.dumps(value, default=str, indent=2)
            except Exception:
                return str(value)

        return pattern.sub(repl, text)

    def _render_complex_placeholders(self, text: str) -> str:
        """
        Optional pass to render placeholders that expect complex renderings:
        - If template contains {{RANKINGS_TABLE}} or similar keys and normalized contains matching structured data,
          we detect and render markdown tables here for known keys.
        """
        # sample mapping: key -> renderer function
        known_table_keys = {
            "METRIC_RANKINGS_TABLE": lambda v: _to_markdown_table_from_list_of_dicts(v) if isinstance(v, list) else str(v),
            "PERFORMANCE_SUMMARY_TABLE": lambda v: _to_markdown_table_from_dict(v) if isinstance(v, dict) else str(v),
            "DRIFT_MODELS_TABLE": lambda v: _to_markdown_table_from_dict(v) if isinstance(v, dict) else str(v),
            "TOP_FEATURES_TABLE": lambda v: _to_markdown_table_from_list_of_dicts(v) if isinstance(v, list) else str(v),
            "RANKINGS_TABLE": lambda v: _to_markdown_table_from_dict(v) if isinstance(v, dict) else str(v),
            "COMPARISON_TABLE": lambda v: _to_markdown_table_from_dict(v) if isinstance(v, dict) else str(v),
        }

        for key, renderer in known_table_keys.items():
            token_variants = [f"{{{{{key}}}}}", f"{{{key}}}"]
            for token in token_variants:
                if token in text:
                    # try normalized lookup
                    v = self.normalized.get(key)
                    if v is None:
                        # also try lower / alternative keys
                        alt = [k for k in self.normalized.keys() if k.upper() == key]
                        v = self.normalized.get(alt[0]) if alt else None
                    if v is not None:
                        try:
                            rendered = renderer(v)
                        except Exception:
                            rendered = str(v)
                        text = text.replace(token, rendered)
                    else:
                        # leave missing placeholder, will be cleaned later
                        continue
        return text

    def _cleanup_unfilled(self, text: str) -> str:
        # Replace remaining {{PLACEHOLDER}} or {PLACEHOLDER} with readable tokens
        def repl(match):
            key = (match.group(1) or match.group(2) or "").upper()
            if not key:
                return match.group(0)
            return f"[MISSING:{key}]"

        pattern = re.compile(r"\{\{\s*([A-Za-z0-9_]+)\s*\}\}|\{\s*([A-Za-z0-9_]+)\s*\}")
        return pattern.sub(repl, text)


def fill_template_placeholders(template: str, analysis_results: Dict[str, Any], strict: bool = False) -> str:
    filler = PlaceholderFiller(template, analysis_results, strict=strict)
    return filler.fill()